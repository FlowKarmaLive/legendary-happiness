<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<title>FlowKarma.Live</title>
<meta charset="utf-8">
<link href="https://fonts.googleapis.com/css?family=Cinzel+Decorative&display=swap" rel="stylesheet">
<style rel="alternate stylesheet" title="Hullo">
h1 {
    color: #ccc;
    font-family: 'Cinzel Decorative', cursive;
}
</style>
<style rel="alternate stylesheet" title="Yeah">
h1 {
    color: #ccc;
    font-family: 'EB Garamond', cursive;
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.9.1/underscore-min.js"></script>
<script src="https://d3js.org/d3.v5.min.js"></script>
<script id="runtime" type="text/javascript">

var cram_color = d3.scaleLinear(
        [0,11],
        ["hsl(0, 50%, 90%)", "hsl(360, 50%, 90%)"]
    ).interpolate(d3.interpolateHslLong),
    w = 978,
    h = 755,
    k = 4,
    chance = 0.08,
    nodes = [],
    links = [],
    colors = d3.scaleLinear(
        [1, k],
        ["hsl(350, 50%, 50%)", "hsl(250, 100%, 50%)"]
    ).interpolate(d3.interpolateHslLong);

const MINUTES = 2

function tim () {
    var i, body = d3.select('body'), h1 = d3.select('h1');
    for (i = 0; i < 12; i++) {
        var c = d3.hsl(cram_color(i))
        body.transition()
            .delay(MINUTES * 5000 * i)
            .duration(MINUTES * 5000)
            .style('background-color', c+"");
        c.h += 180;
        c.s += 0.4;
        h1.transition()
            .delay(MINUTES * 5000 * i)
            .duration(MINUTES * 5000)
            .style('color', c);
    }
}

// var NodeClass = function(x, y) {
//     this.x = x;
//     this.y = y;
//     this.contacts = [];
//     this.newbie = true;
// }

$(function() {

    window.setInterval(tim, MINUTES * 60000);
    tim();


    // var root_node = new NodeClass(w/2, h/2);
    // nodes.push(root_node);

    // var svg = d3.select(".hull").append("svg:svg")
    //     .attr("width", w)
    //     .attr("height", h)
    //     .attr("viewBox", [-w / 2, -h / 2, w, h]);

    // var force = d3.forceSimulation(nodes)
    //     .links(links)
    //     .distance(7)
    //     .size([w, h]);


// ----------------------------------------------------------------


drag = simulation => {
  function dragstarted(d) {
    if (!d3.event.active) simulation.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
  }
  function dragged(d) {
    d.fx = d3.event.x;
    d.fy = d3.event.y;
  }
  function dragended(d) {
    if (!d3.event.active) simulation.alphaTarget(0);
    d.fx = null;
    d.fy = null;
  }
  return d3.drag()
      .on("start", dragstarted)
      .on("drag", dragged)
      .on("end", dragended);
}


//   const simulation = d3.forceSimulation(nodes)
//       .force("link", d3.forceLink(links).id(d => d.id).distance(7).strength(1))
//       .force("charge", d3.forceManyBody().strength(-50))
//       .force("x", d3.forceX())
//       .force("y", d3.forceY());

//   const link = svg.append("g")
//     //   .attr("stroke", "#999")
//     //   .attr("stroke-opacity", 0.6)
//     .selectAll("line")
//     .data(links)
//     .join("line");

//   const node = svg.append("g")
//     //   .attr("fill", "#fff")
//     //   .attr("stroke", "#000")
//     //   .attr("stroke-width", 1.5)
//     .selectAll("circle")
//     .data(nodes)
//     .join("circle")
//     //   .attr("fill", d => d.children ? null : "#000")
//     //   .attr("stroke", d => d.children ? null : "#fff")
//     //   .attr("r", 3.5)
//       .call(drag(simulation));

//   node.append("title")
//       .text(d => d.data.name);

//   simulation.on("tick", () => {
//     link.attr("x1", d => d.source.x)
//         .attr("y1", d => d.source.y)
//         .attr("x2", d => d.target.x)
//         .attr("y2", d => d.target.y);
//     node.attr("cx", d => d.x)
//         .attr("cy", d => d.y);
//   });

//   invalidation.then(() => simulation.stop());


// function restart() {

//   svg.selectAll("line.link")
//       .data(links)
//     .enter().insert("svg:line", "circle.node")
//       .attr("class", "link")
//       .attr("x1", function(d) { return d.source.x; })
//       .attr("y1", function(d) { return d.source.y; })
//       .attr("x2", function(d) { return d.target.x; })
//       .attr("y2", function(d) { return d.target.y; });

//   svg.selectAll("circle.node")
//       .data(nodes)
//     .enter().insert("svg:circle", "circle.cursor")
//       .attr("class", "node")
//       .attr("cx", function(d) { return d.x; })
//       .attr("cy", function(d) { return d.y; })
//       .attr("r", 5)
//       .attr("fill", "yellow")
//     //   .call(drag(simulation))
//     .transition()
//       .duration(150)
//       .attr("fill", function(d) { return colors(d.contacts.length); })
//       .each("end", function(d) {
//         d.newbie = false;
//       });

//   simulation.restart();
// }




// function new_node_2() {
//   var newnodes = [];
//   for (var i = 0; i < nodes.length; i++) {
//     var target = nodes[i];
//     var ratio = target.contacts.length / k; //(target.contacts.length == 0)
//     var n = 1 - ratio;
//     if (target.contacts.length < k && ((n * Math.random()) <= chance)) {
//       var node = new NodeClass(
//         target.x + (Math.random() - 0.5) * 10,
//         target.y + (Math.random() - 0.5) * 10
//       );
//       links.push({source: node, target: target});
//       target.contacts.push(node);
//       node.contacts.push(target);
//       newnodes.push(node);
//     }
//   }
//   _.each(newnodes, function(n){ nodes.push(n);});
//   restart();
//   return newnodes;
// }


// function runloop() {
//     var newnodes;
//     while (true) {
//         newnodes = new_node_2();
//         var count = newnodes.length;
//         if (count > 0) {
//             console.log(count);
//             break;
//         }
//     };

// }

// svg.on("mousedown", runloop);
// restart();

var mindistance = 30

inrange = ({x: sx, y: sy}, {x: tx, y: ty}) => Math.hypot(sx - tx, sy - ty) <= mindistance

//  -----------------------------------------------------------------

  const nodes = [];
  const links = [];
  let mouse = null;

  const svg = d3.select(".hull").append("svg:svg")
      .property("value", {nodes: [], links: []})
      .attr("viewBox", [-w / 2, -h / 2, w, h])
      .attr("cursor", "crosshair")
      .on("mouseleave", mouseleft)
      .on("mousemove", mousemoved)
      .on("click", clicked);

  const simulation = d3.forceSimulation(nodes)
      .force("charge", d3.forceManyBody().strength(-60))
      .force("link", d3.forceLink(links))
      .force("x", d3.forceX())
      .force("y", d3.forceY())
      .on("tick", ticked);

  const dragger = drag(simulation)
      .on("start.mouse", mouseleft)
      .on("end.mouse", mousemoved);

  let link = svg.append("g")
      .attr("stroke", "#999")
    .selectAll("line");

  let mouselink = svg.append("g")
      .attr("stroke", "red")
    .selectAll("line");

  let node = svg.append("g")
    .selectAll("circle");

  const cursor = svg.append("circle")
      .attr("display", "none")
      .attr("fill", "none")
      .attr("stroke", "red")
      .attr("r", mindistance - 5);

  function ticked() {
    node.attr("cx", d => d.x)
        .attr("cy", d => d.y)

    link.attr("x1", d => d.source.x)
        .attr("y1", d => d.source.y)
        .attr("x2", d => d.target.x)
        .attr("y2", d => d.target.y);

    mouselink = mouselink
      .data(mouse ? nodes.filter(node => inrange(mouse, node)) : [])
      .join("line")
        .attr("x1", mouse && mouse.x)
        .attr("y1", mouse && mouse.y)
        .attr("x2", d => d.x)
        .attr("y2", d => d.y);

    cursor
        .attr("display", mouse ? null : "none")
        .attr("cx", mouse && mouse.x)
        .attr("cy", mouse && mouse.y);
  }

  function mouseleft() {
    mouse = null;
  }

  function mousemoved() {
    const [x, y] = d3.mouse(this);
    mouse = {x, y};
    simulation.alpha(0.3).restart();
  }

  function clicked() {
    mousemoved.call(this);
    spawn({x: mouse.x, y: mouse.y});
  }

  function spawn(source) {
    nodes.push(source);

    for (const target of nodes) {
      if (inrange(source, target)) {
        links.push({source, target});
      }
    }

    link = link
      .data(links)
      .join("line");

    node = node
      .data(nodes)
      .join(
        enter => enter.append("circle").attr("r", 0)
          .call(enter => enter.transition().attr("r", 5))
          .call(dragger),
        update => update,
        exit => exit.remove()
      );

    simulation.nodes(nodes);
    simulation.force("link").links(links);
    simulation.alpha(1).restart();

    svg.property("value", {
      nodes: nodes.map(d => ({id: d.index})),
      links: links.map(d => ({source: d.source.index, target: d.target.index}))
    });

    svg.dispatch("input");
  }

  spawn({x: 0, y: 0});



})

</script>
</head>
<body>
<center>
    <div id="main_panel">
        <h1>FlowKarma.Live</h1>
    </div>
    <div class="hull"></div>
</center>
</body>
</html>